### Задание на разработчика Java:

#### Напишите программу, эмулирующую работу диспетчера печати документов.

1. Программа должна быть написана с использованием Java 7.
2. Диспетчер печати может работать с несколькими типами документов (3-5 типов).
3. Каждый тип документа должен иметь уникальные реквизиты: продолжительность печати, наименование типа документа, размер бумаги.
4. Диспетчер помещает в очередь печати неограниченное количество документов. При этом каждый документ может быть обработан,
 только если в это же время не обрабатывается другой документ, время обработки каждого документа равно продолжительности печати данного документа.
5. Диспетчер должен иметь следующие методы:
* Остановка диспетчера. Печать документов в очереди отменяется. На выходе должен быть список ненапечатанных документов.
* Принять документ на печать. Метод не должен блокировать выполнение программы.
* Отменить печать принятого документа, если он еще не был напечатан.
* Получить отсортированный список напечатанных документов. Список может быть отсортирован на выбор: по порядку печати,
 по типу документов, по продолжительности печати, по размеру бумаги.
* Рассчитать среднюю продолжительность печати напечатанных документов

 

#### Правила оформления результатов:

1. Результатом выполнения задания (в зависимости от типа задания) являются текстовые документы, исходные коды/файлы проектов.

2. Скомпилированные/исполняемые модули должны быть исключены из результата.

3. Решение должно запускаться локально, либо при размещении на изолированном веб-сервере, т.е. включать в себя все необходимые зависимости.

4. К результатам необходимо приложить текстовый файл «list.txt», содержащий список направляемых файлов, включая относительные пути.

##### Пример содержания:

PO\Game.java

PO\Helper.java

PO\Сценарий тестирования.docx

PO\Постановка задачи.docx

5. К полным именам всех файлов необходимо добавить второе расширение txt (например, Game.java.txt).

6. После этого все файлы результатов с расширением txt, включая «list.txt», без упаковки в архивы, прикрепляются к ответному письму.

----

Сборка проекта: `./gradlew build`

Сборка докер-контейнера: `sudo docker build -t app .`

Запуск докер-контейнера: `sudo docker run -p 8080:8080 app`

Завершение докер-контейнера: `sudo docker stop CONTAINER ID`

Узнать CONTAINER ID докер-контейнера: `sudo docker ps`

Доступно описание API через SWAGGER: `http://localhost:8080/swagger-ui.html#/document-controller`

Задеплоено на Heroku: `https://centralbank.herokuapp.com`

Соответственно SWAGGER на Heroku: `https://centralbank.herokuapp.com/swagger-ui.html#/document-controller`


<a href="https://priscree.ru/img/e1c9fb450395a3.png" target="_blank">
<img src="https://priscree.ru/img/e1c9fb450395a3.png" border="0"></a>

----

#### Что получилось:
* Есть бэк с роутами через которые можно эмулировать поведение принтера. Используется Future для отмены печати и 
получения ненапечатанных документов, используется ExecutorService для эмуляции очереди печати в одном потоке на принтер.
* Есть несколько типо документо + есть несколько типов размеров документо (Используется enum)
* Для сортировки по полям документов реализованы компараторы
* Есть ManagerService, который распределяет в принтер документы 
* Есть PrinterService, который работается с очередью документов
* Реализованы методы
* Есть тесты
----

#### Что не получилось:
* Не получилось использовать Java 7 (возможно, очень критично). У меня получилось установить JDK 7, которого уже нет в 
репозиториях Ubuntu 18.04, но не получилось "подружить" Spring Boot с java 7. Поэтому взял java 8 и старался не
 использовать то, чего нет в java 7.


----
#### Затрачено времени:
Бэк ~ примерно один вечер и день

#### Сценарии тестирования:
1. Протестировать печать документов через ui-swagger или postman:
* Сделать get-запрос `/api/get-document-by-type` "Получить документ по типу" без параметров 
(будет возвращен документ с параметрами `regular`) или с параметром `type` из
 следующих значений `smallest , small , medium , large , largest , regular`   
 
* "Принять документ на печать" выполнить post-запрос `/api/print`

`{"duration": 7000, "name": "A", "size": "A0", "type": "TYPE_0"}`
`{"duration": 1300, "name": "B", "size": "A1", "type": "TYPE_1"}`

* Сделать get-запрос`/api/get-printed-list` "Получить отсортированный список напечатанных документов"

2. Протестировать среднюю продолжительность печати напечатанных документов:

* Сделать get-запрос `/api/get-average-duration` "Рассчитать среднюю продолжительность печати напечатанных документов"

3. Отмена печати документа:

* Сделать get-запрос `/api/cancel-document-by-name` с параметром nameDocument "canceled" (это название документа)
 "Отменить печать принятого документа, если он еще не был напечатан"
 
 * "Принять документ на печать" выполнить post-запрос `/api/print`
 
 `{"duration": 7000, "name": "canceled", "size": "A0", "type": "TYPE_0"}`
 
 * `/api/get-canceled-list` "Получить отсортированный список ненапечатанных документов"
 
 4. Остановка диспетчера и получить список ненапечатанных документов
 
 * "Принять документ на печать" выполнить post-запрос `/api/print`, чтобы первый документ был с большой
  продолжительностью печати, т.е `"duration": 10000` 10 секунд, затем отправить другие документы
   
   `{"duration": 10000, "name": "A", "size": "A0", "type": "TYPE_0"}`
   `{"duration": 1300, "name": "B", "size": "A1", "type": "TYPE_1"}`

* Сделать get-запрос `/api/stop-manager` "Остановить диспетчер и получить список ненапечатанных документов"

-------

Через swagger и postman неудобно тестировать, но фронт пока что не сделан, есть тесты покрывающие эту логику